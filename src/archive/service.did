type AddTransactionsResponse = variant { ok : Stats; err : text; Full : Stats };
type Archive = service {
  append_transactions : (vec Transaction) -> (AddTransactionsResponse);
  cycles : () -> (nat) query;
  deposit_cycles : () -> ();
  get_transaction : (TxIndex) -> (opt Transaction) query;
  icrc3_get_blocks : (vec TransactionRange) -> (GetTransactionsResult) query;
  remaining_capacity : () -> (nat) query;
  total_transactions : () -> (nat) query;
};
type ArchiveInitArgs = record {
  indexType : IndexType;
  maxPages : nat;
  maxRecords : nat;
  firstIndex : nat;
};
type ArchivedTransactionResponse = record {
  args : vec TransactionRange;
  callback : GetTransactionsFn;
};
type GetTransactionsFn = func (vec TransactionRange) -> (
    GetTransactionsResult,
  ) query;
type GetTransactionsResult = record {
  log_length : nat;
  blocks : vec record { id : nat; block : Value };
  archived_blocks : vec ArchivedTransactionResponse;
};
type IndexType = variant { Stable; StableTyped; Managed };
type Stats = record {
  region : record { id : nat; size : nat64 };
  currentPages : nat64;
  memory : record { pages : opt nat64; type_of : IndexType };
  currentOffset : nat64;
  itemCount : nat;
  maxPages : nat64;
};
type Transaction = variant {
  Int : int;
  Map : vec record { text; Value };
  Nat : nat;
  Blob : vec nat8;
  Text : text;
  Array : vec Value;
};
type TransactionRange = record { start : nat; length : nat };
type TxIndex = nat;
type Value = variant {
  Int : int;
  Map : vec record { text; Value };
  Nat : nat;
  Blob : vec nat8;
  Text : text;
  Array : vec Value;
};
service : Archive